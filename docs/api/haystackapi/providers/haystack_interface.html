<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>haystackapi.providers.haystack_interface API documentation</title>
<meta name="description" content="Base of haystack implementation." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>haystackapi.providers.haystack_interface</code></h1>
</header>
<section id="section-intro">
<p>Base of haystack implementation.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# Abstract interface
# See the accompanying LICENSE file.
# (C) 2021 Engie Digital
#
# vim: set ts=4 sts=4 et tw=78 sw=4 si:
&#34;&#34;&#34;
Base of haystack implementation.
&#34;&#34;&#34;
import logging
import os
import traceback
from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime, date, timedelta, tzinfo
from importlib import import_module
from typing import Any, Tuple, Dict, Optional, List, cast, Union

import pytz
from pytz import BaseTzInfo
from tzlocal import get_localzone

from ..datatypes import Ref, Quantity, Uri
from ..grid import Grid, VER_3_0
from ..grid_filter import parse_hs_datetime_format

log = logging.getLogger(&#34;haystackapi&#34;)


def _to_camel(snake_str: str) -&gt; str:
    first, *others = snake_str.split(&#34;_&#34;)
    return &#34;&#34;.join([first.lower(), *map(str.title, others)])


@dataclass
class HttpError(Exception):
    &#34;&#34;&#34;
    Exception to propagate specific HTTP error
    &#34;&#34;&#34;
    error: int
    msg: str


class HaystackInterface(ABC):
    &#34;&#34;&#34;
    Interface to implement to be compatible with Haystack REST protocol.
    The subclasses may be abstract (implemented only a part of methods),
    the code detect that, and can calculate the set of implemented operations.
    &#34;&#34;&#34;

    @property
    @abstractmethod
    def name(self) -&gt; str:
        raise NotImplementedError()

    def __repr__(self) -&gt; str:
        return self.name

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, exc_traceback):
        pass

    def get_tz(self) -&gt; BaseTzInfo:  # pylint: disable=no-self-use
        return get_localzone()

    def get_customer_id(self) -&gt; str:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Override this for multi-tenant&#34;&#34;&#34;
        return &#39;&#39;

    def values_for_tag(self, tag: str,
                       date_version: Optional[datetime] = None) -&gt; List[Any]:
        &#34;&#34;&#34;Get all values for a given tag

        Args:
            tag (:obj:`str`): tag
            date_version (:obj:`datetime`, optional): version date

        Returns:
            (:obj:`List[Any]`) All unique values for a specific tag
        &#34;&#34;&#34;
        raise NotImplementedError()

    def versions(self) -&gt; List[datetime]:  # pylint: disable=no-self-use
        &#34;&#34;&#34;
        Returns:
            datetime for each version or empty array if unknown
        &#34;&#34;&#34;
        return []

    @abstractmethod
    def about(self, home: str) -&gt; Grid:
        &#34;&#34;&#34;Implement the Haystack &#39;about&#39; ops

        Note:
            Must be completed with &#34;productUri&#34;, &#34;productVersion&#34;, &#34;moduleName&#34; abd &#34;moduleVersion&#34;

        Args:
            home (:obj:`str`): Home url of the API

        Returns:
            (:obj:`Grid`) the default &#39;about&#39; grid.
        &#34;&#34;&#34;
        grid = Grid(
            version=VER_3_0,
            columns=[
                &#34;haystackVersion&#34;,  # Str version of REST implementation
                &#34;tz&#34;,  # Str of server&#39;s default timezone
                &#34;serverName&#34;,  # Str name of the server or project database
                &#34;serverTime&#34;,
                &#34;serverBootTime&#34;,
                &#34;productName&#34;,  # Str name of the server software product
                &#34;productUri&#34;,
                &#34;productVersion&#34;,
                # module which implements Haystack server protocol
                &#34;moduleName&#34;,
                # if its a plug-in to the product
                &#34;moduleVersion&#34;  # Str version of moduleName
            ],
        )
        grid.append(
            {
                &#34;haystackVersion&#34;: str(VER_3_0),
                &#34;tz&#34;: str(self.get_tz()),
                &#34;serverName&#34;: &#34;haystack_&#34; + os.environ.get(&#34;AWS_REGION&#34;, &#34;local&#34;),
                &#34;serverTime&#34;: datetime.now(tz=self.get_tz()).replace(microsecond=0),
                &#34;serverBootTime&#34;: datetime.now(tz=self.get_tz()).replace(
                    microsecond=0
                ),
                &#34;productName&#34;: &#34;Haystack Provider&#34;,
                &#34;productUri&#34;: Uri(home),
                &#34;productVersion&#34;: &#34;0.1&#34;,
                &#34;moduleName&#34;: &#34;AbstractProvider&#34;,
                &#34;moduleVersion&#34;: &#34;0.1&#34;,
            }
        )
        return grid

    def ops(self) -&gt; Grid:
        &#34;&#34;&#34; Implement the Haystack &#39;ops&#39; ops

        Notes:
            Automatically calculate the implemented version.

        Returns:
            A Grid containing &#39;ops&#39; name operations and its related description
        &#34;&#34;&#34;
        grid = Grid(
            version=VER_3_0,
            columns={
                &#34;name&#34;: {},
                &#34;summary&#34;: {},
            },
        )
        all_haystack_ops = {
            &#34;about&#34;: &#34;Summary information for server&#34;,
            &#34;ops&#34;: &#34;Operations supported by this server&#34;,
            &#34;formats&#34;: &#34;Grid data formats supported by this server&#34;,
            &#34;read&#34;: &#34;The read op is used to read a set of entity records either by their unique &#34;
                    &#34;identifier or using a filter.&#34;,
            &#34;nav&#34;: &#34;The nav op is used navigate a project for learning and discovery&#34;,
            &#34;watch_sub&#34;: &#34;The watch_sub operation is used to create new watches &#34;
                         &#34;or add entities to an existing watch.&#34;,
            &#34;watch_unsub&#34;: &#34;The watch_unsub operation is used to close a watch entirely &#34;
                           &#34;or remove entities from a watch.&#34;,
            &#34;watch_poll&#34;: &#34;The watch_poll operation is used to poll a watch for &#34;
                          &#34;changes to the subscribed entity records.&#34;,
            &#34;point_write&#34;: &#34;The point_write_read op is used to: read the current status of a &#34;
                           &#34;writable point&#39;s priority array &#34;
                           &#34;or write to a given level&#34;,
            &#34;his_read&#34;: &#34;The his_read op is used to read a time-series data &#34;
                        &#34;from historized point.&#34;,
            &#34;his_write&#34;: &#34;The his_write op is used to post new time-series &#34;
                         &#34;data to a historized point.&#34;,
            &#34;invoke_action&#34;: &#34;The invoke_action op is used to invoke a &#34;
                             &#34;user action on a target record.&#34;,
        }
        # Remove abstract method
        for abstract_method in self.__class__.__base__.__abstractmethods__:
            all_haystack_ops.pop(abstract_method, None)
        if (
                &#34;point_write_read&#34; in self.__class__.__base__.__abstractmethods__
                or &#34;point_write_write&#34; in self.__class__.__base__.__abstractmethods__
        ):
            all_haystack_ops.pop(&#34;point_write&#34;, None)
        all_haystack_ops = {_to_camel(k): v for k, v in all_haystack_ops.items()}

        grid.extend(
            [
                {&#34;name&#34;: name, &#34;summary&#34;: summary}
                for name, summary in all_haystack_ops.items()
            ]
        )
        return grid

    def formats(self) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;formats&#39; ops

        Notes:
            Implement this method, only if you want to limit the format negotiation
        &#34;&#34;&#34;
        return None  # type: ignore

    @abstractmethod
    def read(
            self,
            limit: int,
            select: Optional[str],
            entity_ids: Optional[List[Ref]],
            grid_filter: Optional[str],
            date_version: Optional[datetime],
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34;
        Implement the Haystack &#39;read&#39; ops

        Args:
            limit (int): The number of record to return or zero
            select (str, optional): The selected tag separated with comma, else &#39;&#39; or &#39;*&#39;
            entity_ids (List[Ref], optional): A list en ids. If set, grid_filter and limit are ignored
            grid_filter (str, optional): A filter to apply. Ignored if entity_ids is set.
            date_version (datetime, optional): The date to return of the last version.

        Returns:
            The requested Grid
        &#34;&#34;&#34;
        # PPR: Add nextToken for paginate ?
        raise NotImplementedError()

    @abstractmethod
    def nav(self, nav_id: str) -&gt; Any:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;nav&#39; ops
        This operation allows servers to expose the database in a human-friendly tree (or graph)
        that can be explored

        Args:
             nav_id (str): The string for nav id column
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def watch_sub(
            self,
            watch_dis: str,
            watch_id: Optional[str],
            ids: List[Ref],
            lease: Optional[int],
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34;
        Implement the Haystack &#39;watchSub&#39; ops

        Args:
            watch_dis (str): Watch description
            watch_id (str, optional): The user watch_id to update or None
            ids (List[Ref]): The list of ids to watch
            lease (int, optional): Lease to apply

        Returns:
            A Grid
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def watch_unsub(
            self, watch_id: str, ids: List[Ref], close: bool
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34;
        Implement the Haystack &#39;watchUnsub&#39; ops

        Args:
            watch_id (str): The user watch_id to update or None
            ids (List[Ref]): The list of ids to watch
            close (bool): Set to True to close

        Returns:
            A Grid
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def watch_poll(
            self, watch_id: str, refresh: bool
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;watchPoll&#39; ops

        Args:
            watch_id (str): The user watch_id to update or None
            refresh (bool): Set to True for refreshing the data

        Returns:
            A Grid where each row corresponds to a watched entity.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def point_write_read(
            self, entity_id: Ref, date_version: Optional[datetime]
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;pointWrite&#39; ops

        Args:
            entity_id (Ref): The entity to update
            date_version (datetime, optional): The optional date version to update

        Returns:
            A Grid
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def point_write_write(
            self,
            entity_id: Ref,
            level: int,
            val: Optional[Any],
            duration: Quantity,
            who: Optional[str],
            date_version: Optional[datetime] = None,
    ) -&gt; None:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;pointWrite&#39; ops

        Args:
            entity_id (Ref): The entity to update
            level (int): Number from 1-17 for level to write
            val (Any, optional): Value to write or null to auto the level
            duration (Quantity): Number with duration unit if setting level 8
            who (str, optional): Optional username performing the write, otherwise user dis is used
            date_version (datetime, optional): The optional date version to update

        Returns:
            None
        &#34;&#34;&#34;
        raise NotImplementedError()

    # Date dates_range must be:
    # &#34;today&#34;
    # &#34;yesterday&#34;
    # &#34;{date}&#34;
    # &#34;{date},{date}&#34;
    # &#34;{dateTime},{dateTime}&#34;
    # &#34;{dateTime}&#34;
    @abstractmethod
    def his_read(
            self,
            entity_id: Ref,
            dates_range: Union[Union[datetime, str], Tuple[datetime, datetime]],
            date_version: Optional[datetime] = None,
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;hisRead&#39; ops

        Args:
            entity_id (Ref): The entity to read
            dates_range (Union[Union[datetime, str], Tuple[datetime, datetime]]): The date
            range. May be &#34;today&#34;, &#34;yesterday&#34;, {date}, ({date},{date}), ({datetime},{datetime}),
            {dateTime}
            date_version ( datetime, optional): The optional date version to update

        Returns:
            A grid
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def his_write(
            self,
            entity_id: Ref,
            time_serie: Grid,
            date_version: Optional[datetime] = None
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;hisWrite&#39; ops

        Args:
            entity_id (Ref): The entity to read
            time_serie (Grid): A grid with a time series
            date_version (datetime, optional): The optional date version to update

        Returns:
            A grid
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def invoke_action(
            self,
            entity_id: Ref,
            action: str,
            params: Dict[str, Any],
            date_version: Optional[datetime] = None
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;invokeAction&#39; ops

        Args:
            entity_id (Ref): The entity to read
            action (str): The action string
            params (Dict[str, Any]): A dictionary with parameters
            date_version (datetime, optional): The optional date version to update

        Returns:
            A grid
        &#34;&#34;&#34;
        raise NotImplementedError()


_providers = {}


def no_cache():
    &#34;&#34;&#34; Must be patched in unit test &#34;&#34;&#34;
    return False


def get_provider(class_str: str) -&gt; HaystackInterface:
    &#34;&#34;&#34;Return an instance of the provider.
    If the provider is an abstract class, create a sub class with all the implementation
    and return an instance of this subclass. Then, the &#39;ops&#39; method can analyse the current instance
    and detect the implemented and abstract methods.

    Args:
        class_str (str): An abstract class string provider

    Returns:
        (HaystackInterface) A instance of this subclass if it exists
    &#34;&#34;&#34;
    try:
        if not class_str.endswith(&#34;.Provider&#34;):
            class_str += &#34;.Provider&#34;
        if class_str in _providers:
            return _providers[class_str]
        module_path, class_name = class_str.rsplit(&#34;.&#34;, 1)
        module = import_module(module_path)
        # Get the abstract class name
        provider_class = getattr(module, class_name)

        # Implement all abstract method.
        # Then, it&#39;s possible to generate the Ops operator dynamically
        # pylint: disable=missing-function-docstring,useless-super-delegation
        class FullInterface(provider_class):  # pylint: disable=missing-class-docstring
            def __init__(self):
                super().__init__()

            def name(self) -&gt; str:
                return super().name()

            def about(
                    self, home: str
            ) -&gt; Grid:  # pylint: disable=missing-function-docstring,useless-super-delegation
                return super().about(home)

            def read(
                    self,
                    limit: int,
                    select: Optional[str],
                    entity_ids: Optional[List[Ref]],
                    grid_filter: Optional[str],
                    date_version: Optional[datetime],
            ) -&gt; Grid:
                # pylint: disable=missing-function-docstring,useless-super-delegation
                return super().read(limit, select, entity_ids, grid_filter, date_version)

            def nav(self, nav_id: str) -&gt; Any:
                # pylint: disable=missing-function-docstring,useless-super-delegation
                return super().nav(nav_id)

            def watch_sub(
                    self,
                    watch_dis: str,
                    watch_id: Optional[str],
                    ids: List[Ref],
                    lease: Optional[int],
            ) -&gt; Grid:
                # pylint: disable=missing-function-docstring,useless-super-delegation
                return super().watch_sub(watch_dis, watch_id, ids, lease)

            def watch_unsub(
                    self, watch_id: str, ids: List[Ref], close_all: bool
            ) -&gt; None:
                # pylint: disable=missing-function-docstring,useless-super-delegation
                return super().watch_unsub(watch_id, ids, close_all)

            def watch_poll(self, watch_id: str, refresh: bool) -&gt; Grid:
                return super().watch_poll(watch_id, refresh)

            def point_write_read(  # pylint: disable=missing-function-docstring,useless-super-delegation
                    self, entity_id: Ref, date_version: Optional[datetime]
            ) -&gt; Grid:
                return super().point_write_read(entity_id, date_version)

            def point_write_write(  # pylint: disable=missing-function-docstring,useless-super-delegation
                    self,
                    entity_id: Ref,
                    level: int,
                    val: Optional[Any],
                    duration: Quantity,
                    who: Optional[str],
                    date_version: Optional[datetime],
            ) -&gt; None:  # pylint: disable=no-self-use
                return super().point_write_write(
                    entity_id, level, val, duration, who, date_version
                )

            def his_read(  # pylint: disable=missing-function-docstring,useless-super-delegation
                    self,
                    entity_id: Ref,
                    date_range: Optional[Tuple[datetime, datetime]],
                    date_version: Optional[datetime],
            ) -&gt; Grid:
                return super().his_read(entity_id, date_range, date_version)

            def his_write(  # pylint: disable=missing-function-docstring, useless-super-delegation
                    self, entity_id: Ref, time_serie: Grid, date_version: Optional[datetime]
            ) -&gt; Grid:
                return super().his_write(entity_id, time_serie, date_version)

            def invoke_action(  # pylint: disable=missing-function-docstring,useless-super-delegation
                    self,
                    entity_id: Ref,
                    action: str,
                    params: Dict[str, Any],
            ) -&gt; Grid:
                return super().invoke_action(entity_id, action, params)

        _providers[class_str] = FullInterface()
        return _providers[class_str]
    except (ImportError, AttributeError):
        traceback.print_exc()
        raise


SINGLETON_PROVIDER = None


def get_singleton_provider() -&gt; HaystackInterface:
    global SINGLETON_PROVIDER  # pylint: disable=global-statement
    assert (
            &#34;HAYSTACK_PROVIDER&#34; in os.environ
    ), &#34;Set &#39;HAYSTACK_PROVIDER&#39; environment variable&#34;
    if not SINGLETON_PROVIDER or no_cache():
        log.debug(&#34;Provider=%s&#34;, os.environ[&#34;HAYSTACK_PROVIDER&#34;])
        SINGLETON_PROVIDER = get_provider(os.environ[&#34;HAYSTACK_PROVIDER&#34;])
    return SINGLETON_PROVIDER


def parse_date_range(date_range: str, timezone: tzinfo) -&gt; Tuple[datetime, datetime]:
    if not date_range:
        return datetime.min.replace(tzinfo=pytz.UTC), \
               datetime.max.replace(tzinfo=pytz.UTC)
    if date_range not in (&#34;today&#34;, &#34;yesterday&#34;):
        split_date = [parse_hs_datetime_format(x) if x else None for x in date_range.split(&#34;,&#34;)]
        if len(split_date) &gt; 1:
            if isinstance(split_date[0], datetime) or isinstance(split_date[1], datetime):
                if not split_date[0]:
                    split_date[0] = datetime.min.replace(tzinfo=pytz.UTC)
                if not split_date[1]:
                    split_date[1] = datetime.max.replace(tzinfo=pytz.UTC)
                assert type(split_date[0]) == type(  # pylint: disable=C0123
                    split_date[1]
                )
                return cast(Tuple[datetime, datetime], tuple(split_date))
            if not split_date[0]:
                split_date[0] = date.min
            if not split_date[1]:
                split_date[1] = date.max
            assert type(split_date[0]) == type(  # pylint: disable=C0123
                split_date[1]
            )
            return \
                (datetime.combine(split_date[0], datetime.min.time()).replace(tzinfo=timezone),
                 datetime.combine(split_date[1], datetime.max.time()).replace(tzinfo=timezone))
        if isinstance(split_date[0], datetime):
            return (split_date[0], datetime.max.replace(tzinfo=pytz.UTC))
        tzdate = datetime.combine(split_date[0], datetime.min.time()).replace(tzinfo=timezone)
        return tzdate, tzdate + timedelta(days=1, milliseconds=-1)
    if date_range == &#34;today&#34;:
        today = datetime.combine(date.today(), datetime.min.time()) \
            .replace(tzinfo=timezone)
        return today, today + timedelta(days=1, milliseconds=-1)
    if date_range == &#34;yesterday&#34;:
        yesterday = datetime.combine(date.today() - timedelta(days=1), datetime.min.time()) \
            .replace(tzinfo=timezone)
        return yesterday, yesterday + timedelta(days=1, milliseconds=-1)
    raise ValueError(f&#34;date_range {date_range} unknown&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="haystackapi.providers.haystack_interface.get_provider"><code class="name flex">
<span>def <span class="ident">get_provider</span></span>(<span>class_str: str) ‑> <a title="haystackapi.providers.haystack_interface.HaystackInterface" href="#haystackapi.providers.haystack_interface.HaystackInterface">HaystackInterface</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return an instance of the provider.
If the provider is an abstract class, create a sub class with all the implementation
and return an instance of this subclass. Then, the 'ops' method can analyse the current instance
and detect the implemented and abstract methods.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>class_str</code></strong> :&ensp;<code>str</code></dt>
<dd>An abstract class string provider</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(HaystackInterface) A instance of this subclass if it exists</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_provider(class_str: str) -&gt; HaystackInterface:
    &#34;&#34;&#34;Return an instance of the provider.
    If the provider is an abstract class, create a sub class with all the implementation
    and return an instance of this subclass. Then, the &#39;ops&#39; method can analyse the current instance
    and detect the implemented and abstract methods.

    Args:
        class_str (str): An abstract class string provider

    Returns:
        (HaystackInterface) A instance of this subclass if it exists
    &#34;&#34;&#34;
    try:
        if not class_str.endswith(&#34;.Provider&#34;):
            class_str += &#34;.Provider&#34;
        if class_str in _providers:
            return _providers[class_str]
        module_path, class_name = class_str.rsplit(&#34;.&#34;, 1)
        module = import_module(module_path)
        # Get the abstract class name
        provider_class = getattr(module, class_name)

        # Implement all abstract method.
        # Then, it&#39;s possible to generate the Ops operator dynamically
        # pylint: disable=missing-function-docstring,useless-super-delegation
        class FullInterface(provider_class):  # pylint: disable=missing-class-docstring
            def __init__(self):
                super().__init__()

            def name(self) -&gt; str:
                return super().name()

            def about(
                    self, home: str
            ) -&gt; Grid:  # pylint: disable=missing-function-docstring,useless-super-delegation
                return super().about(home)

            def read(
                    self,
                    limit: int,
                    select: Optional[str],
                    entity_ids: Optional[List[Ref]],
                    grid_filter: Optional[str],
                    date_version: Optional[datetime],
            ) -&gt; Grid:
                # pylint: disable=missing-function-docstring,useless-super-delegation
                return super().read(limit, select, entity_ids, grid_filter, date_version)

            def nav(self, nav_id: str) -&gt; Any:
                # pylint: disable=missing-function-docstring,useless-super-delegation
                return super().nav(nav_id)

            def watch_sub(
                    self,
                    watch_dis: str,
                    watch_id: Optional[str],
                    ids: List[Ref],
                    lease: Optional[int],
            ) -&gt; Grid:
                # pylint: disable=missing-function-docstring,useless-super-delegation
                return super().watch_sub(watch_dis, watch_id, ids, lease)

            def watch_unsub(
                    self, watch_id: str, ids: List[Ref], close_all: bool
            ) -&gt; None:
                # pylint: disable=missing-function-docstring,useless-super-delegation
                return super().watch_unsub(watch_id, ids, close_all)

            def watch_poll(self, watch_id: str, refresh: bool) -&gt; Grid:
                return super().watch_poll(watch_id, refresh)

            def point_write_read(  # pylint: disable=missing-function-docstring,useless-super-delegation
                    self, entity_id: Ref, date_version: Optional[datetime]
            ) -&gt; Grid:
                return super().point_write_read(entity_id, date_version)

            def point_write_write(  # pylint: disable=missing-function-docstring,useless-super-delegation
                    self,
                    entity_id: Ref,
                    level: int,
                    val: Optional[Any],
                    duration: Quantity,
                    who: Optional[str],
                    date_version: Optional[datetime],
            ) -&gt; None:  # pylint: disable=no-self-use
                return super().point_write_write(
                    entity_id, level, val, duration, who, date_version
                )

            def his_read(  # pylint: disable=missing-function-docstring,useless-super-delegation
                    self,
                    entity_id: Ref,
                    date_range: Optional[Tuple[datetime, datetime]],
                    date_version: Optional[datetime],
            ) -&gt; Grid:
                return super().his_read(entity_id, date_range, date_version)

            def his_write(  # pylint: disable=missing-function-docstring, useless-super-delegation
                    self, entity_id: Ref, time_serie: Grid, date_version: Optional[datetime]
            ) -&gt; Grid:
                return super().his_write(entity_id, time_serie, date_version)

            def invoke_action(  # pylint: disable=missing-function-docstring,useless-super-delegation
                    self,
                    entity_id: Ref,
                    action: str,
                    params: Dict[str, Any],
            ) -&gt; Grid:
                return super().invoke_action(entity_id, action, params)

        _providers[class_str] = FullInterface()
        return _providers[class_str]
    except (ImportError, AttributeError):
        traceback.print_exc()
        raise</code></pre>
</details>
</dd>
<dt id="haystackapi.providers.haystack_interface.get_singleton_provider"><code class="name flex">
<span>def <span class="ident">get_singleton_provider</span></span>(<span>) ‑> <a title="haystackapi.providers.haystack_interface.HaystackInterface" href="#haystackapi.providers.haystack_interface.HaystackInterface">HaystackInterface</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_singleton_provider() -&gt; HaystackInterface:
    global SINGLETON_PROVIDER  # pylint: disable=global-statement
    assert (
            &#34;HAYSTACK_PROVIDER&#34; in os.environ
    ), &#34;Set &#39;HAYSTACK_PROVIDER&#39; environment variable&#34;
    if not SINGLETON_PROVIDER or no_cache():
        log.debug(&#34;Provider=%s&#34;, os.environ[&#34;HAYSTACK_PROVIDER&#34;])
        SINGLETON_PROVIDER = get_provider(os.environ[&#34;HAYSTACK_PROVIDER&#34;])
    return SINGLETON_PROVIDER</code></pre>
</details>
</dd>
<dt id="haystackapi.providers.haystack_interface.no_cache"><code class="name flex">
<span>def <span class="ident">no_cache</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Must be patched in unit test</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def no_cache():
    &#34;&#34;&#34; Must be patched in unit test &#34;&#34;&#34;
    return False</code></pre>
</details>
</dd>
<dt id="haystackapi.providers.haystack_interface.parse_date_range"><code class="name flex">
<span>def <span class="ident">parse_date_range</span></span>(<span>date_range: str, timezone: datetime.tzinfo) ‑> Tuple[datetime.datetime, datetime.datetime]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_date_range(date_range: str, timezone: tzinfo) -&gt; Tuple[datetime, datetime]:
    if not date_range:
        return datetime.min.replace(tzinfo=pytz.UTC), \
               datetime.max.replace(tzinfo=pytz.UTC)
    if date_range not in (&#34;today&#34;, &#34;yesterday&#34;):
        split_date = [parse_hs_datetime_format(x) if x else None for x in date_range.split(&#34;,&#34;)]
        if len(split_date) &gt; 1:
            if isinstance(split_date[0], datetime) or isinstance(split_date[1], datetime):
                if not split_date[0]:
                    split_date[0] = datetime.min.replace(tzinfo=pytz.UTC)
                if not split_date[1]:
                    split_date[1] = datetime.max.replace(tzinfo=pytz.UTC)
                assert type(split_date[0]) == type(  # pylint: disable=C0123
                    split_date[1]
                )
                return cast(Tuple[datetime, datetime], tuple(split_date))
            if not split_date[0]:
                split_date[0] = date.min
            if not split_date[1]:
                split_date[1] = date.max
            assert type(split_date[0]) == type(  # pylint: disable=C0123
                split_date[1]
            )
            return \
                (datetime.combine(split_date[0], datetime.min.time()).replace(tzinfo=timezone),
                 datetime.combine(split_date[1], datetime.max.time()).replace(tzinfo=timezone))
        if isinstance(split_date[0], datetime):
            return (split_date[0], datetime.max.replace(tzinfo=pytz.UTC))
        tzdate = datetime.combine(split_date[0], datetime.min.time()).replace(tzinfo=timezone)
        return tzdate, tzdate + timedelta(days=1, milliseconds=-1)
    if date_range == &#34;today&#34;:
        today = datetime.combine(date.today(), datetime.min.time()) \
            .replace(tzinfo=timezone)
        return today, today + timedelta(days=1, milliseconds=-1)
    if date_range == &#34;yesterday&#34;:
        yesterday = datetime.combine(date.today() - timedelta(days=1), datetime.min.time()) \
            .replace(tzinfo=timezone)
        return yesterday, yesterday + timedelta(days=1, milliseconds=-1)
    raise ValueError(f&#34;date_range {date_range} unknown&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="haystackapi.providers.haystack_interface.HaystackInterface"><code class="flex name class">
<span>class <span class="ident">HaystackInterface</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface to implement to be compatible with Haystack REST protocol.
The subclasses may be abstract (implemented only a part of methods),
the code detect that, and can calculate the set of implemented operations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HaystackInterface(ABC):
    &#34;&#34;&#34;
    Interface to implement to be compatible with Haystack REST protocol.
    The subclasses may be abstract (implemented only a part of methods),
    the code detect that, and can calculate the set of implemented operations.
    &#34;&#34;&#34;

    @property
    @abstractmethod
    def name(self) -&gt; str:
        raise NotImplementedError()

    def __repr__(self) -&gt; str:
        return self.name

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, exc_traceback):
        pass

    def get_tz(self) -&gt; BaseTzInfo:  # pylint: disable=no-self-use
        return get_localzone()

    def get_customer_id(self) -&gt; str:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Override this for multi-tenant&#34;&#34;&#34;
        return &#39;&#39;

    def values_for_tag(self, tag: str,
                       date_version: Optional[datetime] = None) -&gt; List[Any]:
        &#34;&#34;&#34;Get all values for a given tag

        Args:
            tag (:obj:`str`): tag
            date_version (:obj:`datetime`, optional): version date

        Returns:
            (:obj:`List[Any]`) All unique values for a specific tag
        &#34;&#34;&#34;
        raise NotImplementedError()

    def versions(self) -&gt; List[datetime]:  # pylint: disable=no-self-use
        &#34;&#34;&#34;
        Returns:
            datetime for each version or empty array if unknown
        &#34;&#34;&#34;
        return []

    @abstractmethod
    def about(self, home: str) -&gt; Grid:
        &#34;&#34;&#34;Implement the Haystack &#39;about&#39; ops

        Note:
            Must be completed with &#34;productUri&#34;, &#34;productVersion&#34;, &#34;moduleName&#34; abd &#34;moduleVersion&#34;

        Args:
            home (:obj:`str`): Home url of the API

        Returns:
            (:obj:`Grid`) the default &#39;about&#39; grid.
        &#34;&#34;&#34;
        grid = Grid(
            version=VER_3_0,
            columns=[
                &#34;haystackVersion&#34;,  # Str version of REST implementation
                &#34;tz&#34;,  # Str of server&#39;s default timezone
                &#34;serverName&#34;,  # Str name of the server or project database
                &#34;serverTime&#34;,
                &#34;serverBootTime&#34;,
                &#34;productName&#34;,  # Str name of the server software product
                &#34;productUri&#34;,
                &#34;productVersion&#34;,
                # module which implements Haystack server protocol
                &#34;moduleName&#34;,
                # if its a plug-in to the product
                &#34;moduleVersion&#34;  # Str version of moduleName
            ],
        )
        grid.append(
            {
                &#34;haystackVersion&#34;: str(VER_3_0),
                &#34;tz&#34;: str(self.get_tz()),
                &#34;serverName&#34;: &#34;haystack_&#34; + os.environ.get(&#34;AWS_REGION&#34;, &#34;local&#34;),
                &#34;serverTime&#34;: datetime.now(tz=self.get_tz()).replace(microsecond=0),
                &#34;serverBootTime&#34;: datetime.now(tz=self.get_tz()).replace(
                    microsecond=0
                ),
                &#34;productName&#34;: &#34;Haystack Provider&#34;,
                &#34;productUri&#34;: Uri(home),
                &#34;productVersion&#34;: &#34;0.1&#34;,
                &#34;moduleName&#34;: &#34;AbstractProvider&#34;,
                &#34;moduleVersion&#34;: &#34;0.1&#34;,
            }
        )
        return grid

    def ops(self) -&gt; Grid:
        &#34;&#34;&#34; Implement the Haystack &#39;ops&#39; ops

        Notes:
            Automatically calculate the implemented version.

        Returns:
            A Grid containing &#39;ops&#39; name operations and its related description
        &#34;&#34;&#34;
        grid = Grid(
            version=VER_3_0,
            columns={
                &#34;name&#34;: {},
                &#34;summary&#34;: {},
            },
        )
        all_haystack_ops = {
            &#34;about&#34;: &#34;Summary information for server&#34;,
            &#34;ops&#34;: &#34;Operations supported by this server&#34;,
            &#34;formats&#34;: &#34;Grid data formats supported by this server&#34;,
            &#34;read&#34;: &#34;The read op is used to read a set of entity records either by their unique &#34;
                    &#34;identifier or using a filter.&#34;,
            &#34;nav&#34;: &#34;The nav op is used navigate a project for learning and discovery&#34;,
            &#34;watch_sub&#34;: &#34;The watch_sub operation is used to create new watches &#34;
                         &#34;or add entities to an existing watch.&#34;,
            &#34;watch_unsub&#34;: &#34;The watch_unsub operation is used to close a watch entirely &#34;
                           &#34;or remove entities from a watch.&#34;,
            &#34;watch_poll&#34;: &#34;The watch_poll operation is used to poll a watch for &#34;
                          &#34;changes to the subscribed entity records.&#34;,
            &#34;point_write&#34;: &#34;The point_write_read op is used to: read the current status of a &#34;
                           &#34;writable point&#39;s priority array &#34;
                           &#34;or write to a given level&#34;,
            &#34;his_read&#34;: &#34;The his_read op is used to read a time-series data &#34;
                        &#34;from historized point.&#34;,
            &#34;his_write&#34;: &#34;The his_write op is used to post new time-series &#34;
                         &#34;data to a historized point.&#34;,
            &#34;invoke_action&#34;: &#34;The invoke_action op is used to invoke a &#34;
                             &#34;user action on a target record.&#34;,
        }
        # Remove abstract method
        for abstract_method in self.__class__.__base__.__abstractmethods__:
            all_haystack_ops.pop(abstract_method, None)
        if (
                &#34;point_write_read&#34; in self.__class__.__base__.__abstractmethods__
                or &#34;point_write_write&#34; in self.__class__.__base__.__abstractmethods__
        ):
            all_haystack_ops.pop(&#34;point_write&#34;, None)
        all_haystack_ops = {_to_camel(k): v for k, v in all_haystack_ops.items()}

        grid.extend(
            [
                {&#34;name&#34;: name, &#34;summary&#34;: summary}
                for name, summary in all_haystack_ops.items()
            ]
        )
        return grid

    def formats(self) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;formats&#39; ops

        Notes:
            Implement this method, only if you want to limit the format negotiation
        &#34;&#34;&#34;
        return None  # type: ignore

    @abstractmethod
    def read(
            self,
            limit: int,
            select: Optional[str],
            entity_ids: Optional[List[Ref]],
            grid_filter: Optional[str],
            date_version: Optional[datetime],
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34;
        Implement the Haystack &#39;read&#39; ops

        Args:
            limit (int): The number of record to return or zero
            select (str, optional): The selected tag separated with comma, else &#39;&#39; or &#39;*&#39;
            entity_ids (List[Ref], optional): A list en ids. If set, grid_filter and limit are ignored
            grid_filter (str, optional): A filter to apply. Ignored if entity_ids is set.
            date_version (datetime, optional): The date to return of the last version.

        Returns:
            The requested Grid
        &#34;&#34;&#34;
        # PPR: Add nextToken for paginate ?
        raise NotImplementedError()

    @abstractmethod
    def nav(self, nav_id: str) -&gt; Any:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;nav&#39; ops
        This operation allows servers to expose the database in a human-friendly tree (or graph)
        that can be explored

        Args:
             nav_id (str): The string for nav id column
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def watch_sub(
            self,
            watch_dis: str,
            watch_id: Optional[str],
            ids: List[Ref],
            lease: Optional[int],
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34;
        Implement the Haystack &#39;watchSub&#39; ops

        Args:
            watch_dis (str): Watch description
            watch_id (str, optional): The user watch_id to update or None
            ids (List[Ref]): The list of ids to watch
            lease (int, optional): Lease to apply

        Returns:
            A Grid
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def watch_unsub(
            self, watch_id: str, ids: List[Ref], close: bool
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34;
        Implement the Haystack &#39;watchUnsub&#39; ops

        Args:
            watch_id (str): The user watch_id to update or None
            ids (List[Ref]): The list of ids to watch
            close (bool): Set to True to close

        Returns:
            A Grid
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def watch_poll(
            self, watch_id: str, refresh: bool
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;watchPoll&#39; ops

        Args:
            watch_id (str): The user watch_id to update or None
            refresh (bool): Set to True for refreshing the data

        Returns:
            A Grid where each row corresponds to a watched entity.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def point_write_read(
            self, entity_id: Ref, date_version: Optional[datetime]
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;pointWrite&#39; ops

        Args:
            entity_id (Ref): The entity to update
            date_version (datetime, optional): The optional date version to update

        Returns:
            A Grid
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def point_write_write(
            self,
            entity_id: Ref,
            level: int,
            val: Optional[Any],
            duration: Quantity,
            who: Optional[str],
            date_version: Optional[datetime] = None,
    ) -&gt; None:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;pointWrite&#39; ops

        Args:
            entity_id (Ref): The entity to update
            level (int): Number from 1-17 for level to write
            val (Any, optional): Value to write or null to auto the level
            duration (Quantity): Number with duration unit if setting level 8
            who (str, optional): Optional username performing the write, otherwise user dis is used
            date_version (datetime, optional): The optional date version to update

        Returns:
            None
        &#34;&#34;&#34;
        raise NotImplementedError()

    # Date dates_range must be:
    # &#34;today&#34;
    # &#34;yesterday&#34;
    # &#34;{date}&#34;
    # &#34;{date},{date}&#34;
    # &#34;{dateTime},{dateTime}&#34;
    # &#34;{dateTime}&#34;
    @abstractmethod
    def his_read(
            self,
            entity_id: Ref,
            dates_range: Union[Union[datetime, str], Tuple[datetime, datetime]],
            date_version: Optional[datetime] = None,
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;hisRead&#39; ops

        Args:
            entity_id (Ref): The entity to read
            dates_range (Union[Union[datetime, str], Tuple[datetime, datetime]]): The date
            range. May be &#34;today&#34;, &#34;yesterday&#34;, {date}, ({date},{date}), ({datetime},{datetime}),
            {dateTime}
            date_version ( datetime, optional): The optional date version to update

        Returns:
            A grid
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def his_write(
            self,
            entity_id: Ref,
            time_serie: Grid,
            date_version: Optional[datetime] = None
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;hisWrite&#39; ops

        Args:
            entity_id (Ref): The entity to read
            time_serie (Grid): A grid with a time series
            date_version (datetime, optional): The optional date version to update

        Returns:
            A grid
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def invoke_action(
            self,
            entity_id: Ref,
            action: str,
            params: Dict[str, Any],
            date_version: Optional[datetime] = None
    ) -&gt; Grid:  # pylint: disable=no-self-use
        &#34;&#34;&#34; Implement the Haystack &#39;invokeAction&#39; ops

        Args:
            entity_id (Ref): The entity to read
            action (str): The action string
            params (Dict[str, Any]): A dictionary with parameters
            date_version (datetime, optional): The optional date version to update

        Returns:
            A grid
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="haystackapi.providers.ping.Provider" href="ping.html#haystackapi.providers.ping.Provider">Provider</a></li>
<li><a title="haystackapi.providers.sql.Provider" href="sql.html#haystackapi.providers.sql.Provider">Provider</a></li>
<li><a title="haystackapi.providers.url.Provider" href="url.html#haystackapi.providers.url.Provider">Provider</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="haystackapi.providers.haystack_interface.HaystackInterface.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def name(self) -&gt; str:
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="haystackapi.providers.haystack_interface.HaystackInterface.about"><code class="name flex">
<span>def <span class="ident">about</span></span>(<span>self, home: str) ‑> haystackapi.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'about' ops</p>
<h2 id="note">Note</h2>
<p>Must be completed with "productUri", "productVersion", "moduleName" abd "moduleVersion"</p>
<h2 id="args">Args</h2>
<p>home (:obj:<code>str</code>): Home url of the API</p>
<h2 id="returns">Returns</h2>
<p>(:obj:<code>Grid</code>) the default 'about' grid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def about(self, home: str) -&gt; Grid:
    &#34;&#34;&#34;Implement the Haystack &#39;about&#39; ops

    Note:
        Must be completed with &#34;productUri&#34;, &#34;productVersion&#34;, &#34;moduleName&#34; abd &#34;moduleVersion&#34;

    Args:
        home (:obj:`str`): Home url of the API

    Returns:
        (:obj:`Grid`) the default &#39;about&#39; grid.
    &#34;&#34;&#34;
    grid = Grid(
        version=VER_3_0,
        columns=[
            &#34;haystackVersion&#34;,  # Str version of REST implementation
            &#34;tz&#34;,  # Str of server&#39;s default timezone
            &#34;serverName&#34;,  # Str name of the server or project database
            &#34;serverTime&#34;,
            &#34;serverBootTime&#34;,
            &#34;productName&#34;,  # Str name of the server software product
            &#34;productUri&#34;,
            &#34;productVersion&#34;,
            # module which implements Haystack server protocol
            &#34;moduleName&#34;,
            # if its a plug-in to the product
            &#34;moduleVersion&#34;  # Str version of moduleName
        ],
    )
    grid.append(
        {
            &#34;haystackVersion&#34;: str(VER_3_0),
            &#34;tz&#34;: str(self.get_tz()),
            &#34;serverName&#34;: &#34;haystack_&#34; + os.environ.get(&#34;AWS_REGION&#34;, &#34;local&#34;),
            &#34;serverTime&#34;: datetime.now(tz=self.get_tz()).replace(microsecond=0),
            &#34;serverBootTime&#34;: datetime.now(tz=self.get_tz()).replace(
                microsecond=0
            ),
            &#34;productName&#34;: &#34;Haystack Provider&#34;,
            &#34;productUri&#34;: Uri(home),
            &#34;productVersion&#34;: &#34;0.1&#34;,
            &#34;moduleName&#34;: &#34;AbstractProvider&#34;,
            &#34;moduleVersion&#34;: &#34;0.1&#34;,
        }
    )
    return grid</code></pre>
</details>
</dd>
<dt id="haystackapi.providers.haystack_interface.HaystackInterface.formats"><code class="name flex">
<span>def <span class="ident">formats</span></span>(<span>self) ‑> haystackapi.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'formats' ops</p>
<h2 id="notes">Notes</h2>
<p>Implement this method, only if you want to limit the format negotiation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def formats(self) -&gt; Grid:  # pylint: disable=no-self-use
    &#34;&#34;&#34; Implement the Haystack &#39;formats&#39; ops

    Notes:
        Implement this method, only if you want to limit the format negotiation
    &#34;&#34;&#34;
    return None  # type: ignore</code></pre>
</details>
</dd>
<dt id="haystackapi.providers.haystack_interface.HaystackInterface.get_customer_id"><code class="name flex">
<span>def <span class="ident">get_customer_id</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Override this for multi-tenant</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_customer_id(self) -&gt; str:  # pylint: disable=no-self-use
    &#34;&#34;&#34; Override this for multi-tenant&#34;&#34;&#34;
    return &#39;&#39;</code></pre>
</details>
</dd>
<dt id="haystackapi.providers.haystack_interface.HaystackInterface.get_tz"><code class="name flex">
<span>def <span class="ident">get_tz</span></span>(<span>self) ‑> pytz.tzinfo.BaseTzInfo</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tz(self) -&gt; BaseTzInfo:  # pylint: disable=no-self-use
    return get_localzone()</code></pre>
</details>
</dd>
<dt id="haystackapi.providers.haystack_interface.HaystackInterface.his_read"><code class="name flex">
<span>def <span class="ident">his_read</span></span>(<span>self, entity_id: haystackapi.datatypes.Ref, dates_range: Union[datetime.datetime, str, Tuple[datetime.datetime, datetime.datetime]], date_version: Union[datetime.datetime, NoneType] = None) ‑> haystackapi.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'hisRead' ops</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entity_id</code></strong> :&ensp;<code>Ref</code></dt>
<dd>The entity to read</dd>
<dt><strong><code>dates_range</code></strong> :&ensp;<code>Union[Union[datetime, str], Tuple[datetime, datetime]]</code></dt>
<dd>The date</dd>
<dt>range. May be "today", "yesterday", {date}, ({date},{date}), ({datetime},{datetime}),</dt>
<dt>{dateTime}</dt>
<dt><strong><code>date_version</code></strong> :&ensp;<code> datetime</code>, optional</dt>
<dd>The optional date version to update</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A grid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def his_read(
        self,
        entity_id: Ref,
        dates_range: Union[Union[datetime, str], Tuple[datetime, datetime]],
        date_version: Optional[datetime] = None,
) -&gt; Grid:  # pylint: disable=no-self-use
    &#34;&#34;&#34; Implement the Haystack &#39;hisRead&#39; ops

    Args:
        entity_id (Ref): The entity to read
        dates_range (Union[Union[datetime, str], Tuple[datetime, datetime]]): The date
        range. May be &#34;today&#34;, &#34;yesterday&#34;, {date}, ({date},{date}), ({datetime},{datetime}),
        {dateTime}
        date_version ( datetime, optional): The optional date version to update

    Returns:
        A grid
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="haystackapi.providers.haystack_interface.HaystackInterface.his_write"><code class="name flex">
<span>def <span class="ident">his_write</span></span>(<span>self, entity_id: haystackapi.datatypes.Ref, time_serie: haystackapi.grid.Grid, date_version: Union[datetime.datetime, NoneType] = None) ‑> haystackapi.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'hisWrite' ops</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entity_id</code></strong> :&ensp;<code>Ref</code></dt>
<dd>The entity to read</dd>
<dt><strong><code>time_serie</code></strong> :&ensp;<code>Grid</code></dt>
<dd>A grid with a time series</dd>
<dt><strong><code>date_version</code></strong> :&ensp;<code>datetime</code>, optional</dt>
<dd>The optional date version to update</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A grid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def his_write(
        self,
        entity_id: Ref,
        time_serie: Grid,
        date_version: Optional[datetime] = None
) -&gt; Grid:  # pylint: disable=no-self-use
    &#34;&#34;&#34; Implement the Haystack &#39;hisWrite&#39; ops

    Args:
        entity_id (Ref): The entity to read
        time_serie (Grid): A grid with a time series
        date_version (datetime, optional): The optional date version to update

    Returns:
        A grid
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="haystackapi.providers.haystack_interface.HaystackInterface.invoke_action"><code class="name flex">
<span>def <span class="ident">invoke_action</span></span>(<span>self, entity_id: haystackapi.datatypes.Ref, action: str, params: Dict[str, Any], date_version: Union[datetime.datetime, NoneType] = None) ‑> haystackapi.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'invokeAction' ops</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entity_id</code></strong> :&ensp;<code>Ref</code></dt>
<dd>The entity to read</dd>
<dt><strong><code>action</code></strong> :&ensp;<code>str</code></dt>
<dd>The action string</dd>
<dt><strong><code>params</code></strong> :&ensp;<code>Dict[str, Any]</code></dt>
<dd>A dictionary with parameters</dd>
<dt><strong><code>date_version</code></strong> :&ensp;<code>datetime</code>, optional</dt>
<dd>The optional date version to update</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A grid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def invoke_action(
        self,
        entity_id: Ref,
        action: str,
        params: Dict[str, Any],
        date_version: Optional[datetime] = None
) -&gt; Grid:  # pylint: disable=no-self-use
    &#34;&#34;&#34; Implement the Haystack &#39;invokeAction&#39; ops

    Args:
        entity_id (Ref): The entity to read
        action (str): The action string
        params (Dict[str, Any]): A dictionary with parameters
        date_version (datetime, optional): The optional date version to update

    Returns:
        A grid
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="haystackapi.providers.haystack_interface.HaystackInterface.nav"><code class="name flex">
<span>def <span class="ident">nav</span></span>(<span>self, nav_id: str) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'nav' ops
This operation allows servers to expose the database in a human-friendly tree (or graph)
that can be explored</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>nav_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The string for nav id column</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def nav(self, nav_id: str) -&gt; Any:  # pylint: disable=no-self-use
    &#34;&#34;&#34; Implement the Haystack &#39;nav&#39; ops
    This operation allows servers to expose the database in a human-friendly tree (or graph)
    that can be explored

    Args:
         nav_id (str): The string for nav id column
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="haystackapi.providers.haystack_interface.HaystackInterface.ops"><code class="name flex">
<span>def <span class="ident">ops</span></span>(<span>self) ‑> haystackapi.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'ops' ops</p>
<h2 id="notes">Notes</h2>
<p>Automatically calculate the implemented version.</p>
<h2 id="returns">Returns</h2>
<p>A Grid containing 'ops' name operations and its related description</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ops(self) -&gt; Grid:
    &#34;&#34;&#34; Implement the Haystack &#39;ops&#39; ops

    Notes:
        Automatically calculate the implemented version.

    Returns:
        A Grid containing &#39;ops&#39; name operations and its related description
    &#34;&#34;&#34;
    grid = Grid(
        version=VER_3_0,
        columns={
            &#34;name&#34;: {},
            &#34;summary&#34;: {},
        },
    )
    all_haystack_ops = {
        &#34;about&#34;: &#34;Summary information for server&#34;,
        &#34;ops&#34;: &#34;Operations supported by this server&#34;,
        &#34;formats&#34;: &#34;Grid data formats supported by this server&#34;,
        &#34;read&#34;: &#34;The read op is used to read a set of entity records either by their unique &#34;
                &#34;identifier or using a filter.&#34;,
        &#34;nav&#34;: &#34;The nav op is used navigate a project for learning and discovery&#34;,
        &#34;watch_sub&#34;: &#34;The watch_sub operation is used to create new watches &#34;
                     &#34;or add entities to an existing watch.&#34;,
        &#34;watch_unsub&#34;: &#34;The watch_unsub operation is used to close a watch entirely &#34;
                       &#34;or remove entities from a watch.&#34;,
        &#34;watch_poll&#34;: &#34;The watch_poll operation is used to poll a watch for &#34;
                      &#34;changes to the subscribed entity records.&#34;,
        &#34;point_write&#34;: &#34;The point_write_read op is used to: read the current status of a &#34;
                       &#34;writable point&#39;s priority array &#34;
                       &#34;or write to a given level&#34;,
        &#34;his_read&#34;: &#34;The his_read op is used to read a time-series data &#34;
                    &#34;from historized point.&#34;,
        &#34;his_write&#34;: &#34;The his_write op is used to post new time-series &#34;
                     &#34;data to a historized point.&#34;,
        &#34;invoke_action&#34;: &#34;The invoke_action op is used to invoke a &#34;
                         &#34;user action on a target record.&#34;,
    }
    # Remove abstract method
    for abstract_method in self.__class__.__base__.__abstractmethods__:
        all_haystack_ops.pop(abstract_method, None)
    if (
            &#34;point_write_read&#34; in self.__class__.__base__.__abstractmethods__
            or &#34;point_write_write&#34; in self.__class__.__base__.__abstractmethods__
    ):
        all_haystack_ops.pop(&#34;point_write&#34;, None)
    all_haystack_ops = {_to_camel(k): v for k, v in all_haystack_ops.items()}

    grid.extend(
        [
            {&#34;name&#34;: name, &#34;summary&#34;: summary}
            for name, summary in all_haystack_ops.items()
        ]
    )
    return grid</code></pre>
</details>
</dd>
<dt id="haystackapi.providers.haystack_interface.HaystackInterface.point_write_read"><code class="name flex">
<span>def <span class="ident">point_write_read</span></span>(<span>self, entity_id: haystackapi.datatypes.Ref, date_version: Union[datetime.datetime, NoneType]) ‑> haystackapi.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'pointWrite' ops</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entity_id</code></strong> :&ensp;<code>Ref</code></dt>
<dd>The entity to update</dd>
<dt><strong><code>date_version</code></strong> :&ensp;<code>datetime</code>, optional</dt>
<dd>The optional date version to update</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Grid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def point_write_read(
        self, entity_id: Ref, date_version: Optional[datetime]
) -&gt; Grid:  # pylint: disable=no-self-use
    &#34;&#34;&#34; Implement the Haystack &#39;pointWrite&#39; ops

    Args:
        entity_id (Ref): The entity to update
        date_version (datetime, optional): The optional date version to update

    Returns:
        A Grid
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="haystackapi.providers.haystack_interface.HaystackInterface.point_write_write"><code class="name flex">
<span>def <span class="ident">point_write_write</span></span>(<span>self, entity_id: haystackapi.datatypes.Ref, level: int, val: Union[Any, NoneType], duration: haystackapi.datatypes.Quantity, who: Union[str, NoneType], date_version: Union[datetime.datetime, NoneType] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'pointWrite' ops</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entity_id</code></strong> :&ensp;<code>Ref</code></dt>
<dd>The entity to update</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>int</code></dt>
<dd>Number from 1-17 for level to write</dd>
<dt><strong><code>val</code></strong> :&ensp;<code>Any</code>, optional</dt>
<dd>Value to write or null to auto the level</dd>
<dt><strong><code>duration</code></strong> :&ensp;<code>Quantity</code></dt>
<dd>Number with duration unit if setting level 8</dd>
<dt><strong><code>who</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Optional username performing the write, otherwise user dis is used</dd>
<dt><strong><code>date_version</code></strong> :&ensp;<code>datetime</code>, optional</dt>
<dd>The optional date version to update</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def point_write_write(
        self,
        entity_id: Ref,
        level: int,
        val: Optional[Any],
        duration: Quantity,
        who: Optional[str],
        date_version: Optional[datetime] = None,
) -&gt; None:  # pylint: disable=no-self-use
    &#34;&#34;&#34; Implement the Haystack &#39;pointWrite&#39; ops

    Args:
        entity_id (Ref): The entity to update
        level (int): Number from 1-17 for level to write
        val (Any, optional): Value to write or null to auto the level
        duration (Quantity): Number with duration unit if setting level 8
        who (str, optional): Optional username performing the write, otherwise user dis is used
        date_version (datetime, optional): The optional date version to update

    Returns:
        None
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="haystackapi.providers.haystack_interface.HaystackInterface.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, limit: int, select: Union[str, NoneType], entity_ids: Union[List[haystackapi.datatypes.Ref], NoneType], grid_filter: Union[str, NoneType], date_version: Union[datetime.datetime, NoneType]) ‑> haystackapi.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'read' ops</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>limit</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of record to return or zero</dd>
<dt><strong><code>select</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The selected tag separated with comma, else '' or '*'</dd>
<dt><strong><code>entity_ids</code></strong> :&ensp;<code>List[Ref]</code>, optional</dt>
<dd>A list en ids. If set, grid_filter and limit are ignored</dd>
<dt><strong><code>grid_filter</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A filter to apply. Ignored if entity_ids is set.</dd>
<dt><strong><code>date_version</code></strong> :&ensp;<code>datetime</code>, optional</dt>
<dd>The date to return of the last version.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The requested Grid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def read(
        self,
        limit: int,
        select: Optional[str],
        entity_ids: Optional[List[Ref]],
        grid_filter: Optional[str],
        date_version: Optional[datetime],
) -&gt; Grid:  # pylint: disable=no-self-use
    &#34;&#34;&#34;
    Implement the Haystack &#39;read&#39; ops

    Args:
        limit (int): The number of record to return or zero
        select (str, optional): The selected tag separated with comma, else &#39;&#39; or &#39;*&#39;
        entity_ids (List[Ref], optional): A list en ids. If set, grid_filter and limit are ignored
        grid_filter (str, optional): A filter to apply. Ignored if entity_ids is set.
        date_version (datetime, optional): The date to return of the last version.

    Returns:
        The requested Grid
    &#34;&#34;&#34;
    # PPR: Add nextToken for paginate ?
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="haystackapi.providers.haystack_interface.HaystackInterface.values_for_tag"><code class="name flex">
<span>def <span class="ident">values_for_tag</span></span>(<span>self, tag: str, date_version: Union[datetime.datetime, NoneType] = None) ‑> List[Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Get all values for a given tag</p>
<h2 id="args">Args</h2>
<p>tag (:obj:<code>str</code>): tag
date_version (:obj:<code>datetime</code>, optional): version date</p>
<h2 id="returns">Returns</h2>
<p>(:obj:<code>List[Any]</code>) All unique values for a specific tag</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def values_for_tag(self, tag: str,
                   date_version: Optional[datetime] = None) -&gt; List[Any]:
    &#34;&#34;&#34;Get all values for a given tag

    Args:
        tag (:obj:`str`): tag
        date_version (:obj:`datetime`, optional): version date

    Returns:
        (:obj:`List[Any]`) All unique values for a specific tag
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="haystackapi.providers.haystack_interface.HaystackInterface.versions"><code class="name flex">
<span>def <span class="ident">versions</span></span>(<span>self) ‑> List[datetime.datetime]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<p>datetime for each version or empty array if unknown</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def versions(self) -&gt; List[datetime]:  # pylint: disable=no-self-use
    &#34;&#34;&#34;
    Returns:
        datetime for each version or empty array if unknown
    &#34;&#34;&#34;
    return []</code></pre>
</details>
</dd>
<dt id="haystackapi.providers.haystack_interface.HaystackInterface.watch_poll"><code class="name flex">
<span>def <span class="ident">watch_poll</span></span>(<span>self, watch_id: str, refresh: bool) ‑> haystackapi.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'watchPoll' ops</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>watch_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The user watch_id to update or None</dd>
<dt><strong><code>refresh</code></strong> :&ensp;<code>bool</code></dt>
<dd>Set to True for refreshing the data</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Grid where each row corresponds to a watched entity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def watch_poll(
        self, watch_id: str, refresh: bool
) -&gt; Grid:  # pylint: disable=no-self-use
    &#34;&#34;&#34; Implement the Haystack &#39;watchPoll&#39; ops

    Args:
        watch_id (str): The user watch_id to update or None
        refresh (bool): Set to True for refreshing the data

    Returns:
        A Grid where each row corresponds to a watched entity.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="haystackapi.providers.haystack_interface.HaystackInterface.watch_sub"><code class="name flex">
<span>def <span class="ident">watch_sub</span></span>(<span>self, watch_dis: str, watch_id: Union[str, NoneType], ids: List[haystackapi.datatypes.Ref], lease: Union[int, NoneType]) ‑> haystackapi.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'watchSub' ops</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>watch_dis</code></strong> :&ensp;<code>str</code></dt>
<dd>Watch description</dd>
<dt><strong><code>watch_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The user watch_id to update or None</dd>
<dt><strong><code>ids</code></strong> :&ensp;<code>List[Ref]</code></dt>
<dd>The list of ids to watch</dd>
<dt><strong><code>lease</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Lease to apply</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Grid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def watch_sub(
        self,
        watch_dis: str,
        watch_id: Optional[str],
        ids: List[Ref],
        lease: Optional[int],
) -&gt; Grid:  # pylint: disable=no-self-use
    &#34;&#34;&#34;
    Implement the Haystack &#39;watchSub&#39; ops

    Args:
        watch_dis (str): Watch description
        watch_id (str, optional): The user watch_id to update or None
        ids (List[Ref]): The list of ids to watch
        lease (int, optional): Lease to apply

    Returns:
        A Grid
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="haystackapi.providers.haystack_interface.HaystackInterface.watch_unsub"><code class="name flex">
<span>def <span class="ident">watch_unsub</span></span>(<span>self, watch_id: str, ids: List[haystackapi.datatypes.Ref], close: bool) ‑> haystackapi.grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Haystack 'watchUnsub' ops</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>watch_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The user watch_id to update or None</dd>
<dt><strong><code>ids</code></strong> :&ensp;<code>List[Ref]</code></dt>
<dd>The list of ids to watch</dd>
<dt><strong><code>close</code></strong> :&ensp;<code>bool</code></dt>
<dd>Set to True to close</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Grid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def watch_unsub(
        self, watch_id: str, ids: List[Ref], close: bool
) -&gt; Grid:  # pylint: disable=no-self-use
    &#34;&#34;&#34;
    Implement the Haystack &#39;watchUnsub&#39; ops

    Args:
        watch_id (str): The user watch_id to update or None
        ids (List[Ref]): The list of ids to watch
        close (bool): Set to True to close

    Returns:
        A Grid
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="haystackapi.providers.haystack_interface.HttpError"><code class="flex name class">
<span>class <span class="ident">HttpError</span></span>
<span>(</span><span>error: int, msg: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Exception to propagate specific HTTP error</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HttpError(Exception):
    &#34;&#34;&#34;
    Exception to propagate specific HTTP error
    &#34;&#34;&#34;
    error: int
    msg: str</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="haystackapi.providers.haystack_interface.HttpError.error"><code class="name">var <span class="ident">error</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="haystackapi.providers.haystack_interface.HttpError.msg"><code class="name">var <span class="ident">msg</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="haystackapi.providers" href="index.html">haystackapi.providers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="haystackapi.providers.haystack_interface.get_provider" href="#haystackapi.providers.haystack_interface.get_provider">get_provider</a></code></li>
<li><code><a title="haystackapi.providers.haystack_interface.get_singleton_provider" href="#haystackapi.providers.haystack_interface.get_singleton_provider">get_singleton_provider</a></code></li>
<li><code><a title="haystackapi.providers.haystack_interface.no_cache" href="#haystackapi.providers.haystack_interface.no_cache">no_cache</a></code></li>
<li><code><a title="haystackapi.providers.haystack_interface.parse_date_range" href="#haystackapi.providers.haystack_interface.parse_date_range">parse_date_range</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="haystackapi.providers.haystack_interface.HaystackInterface" href="#haystackapi.providers.haystack_interface.HaystackInterface">HaystackInterface</a></code></h4>
<ul class="two-column">
<li><code><a title="haystackapi.providers.haystack_interface.HaystackInterface.about" href="#haystackapi.providers.haystack_interface.HaystackInterface.about">about</a></code></li>
<li><code><a title="haystackapi.providers.haystack_interface.HaystackInterface.formats" href="#haystackapi.providers.haystack_interface.HaystackInterface.formats">formats</a></code></li>
<li><code><a title="haystackapi.providers.haystack_interface.HaystackInterface.get_customer_id" href="#haystackapi.providers.haystack_interface.HaystackInterface.get_customer_id">get_customer_id</a></code></li>
<li><code><a title="haystackapi.providers.haystack_interface.HaystackInterface.get_tz" href="#haystackapi.providers.haystack_interface.HaystackInterface.get_tz">get_tz</a></code></li>
<li><code><a title="haystackapi.providers.haystack_interface.HaystackInterface.his_read" href="#haystackapi.providers.haystack_interface.HaystackInterface.his_read">his_read</a></code></li>
<li><code><a title="haystackapi.providers.haystack_interface.HaystackInterface.his_write" href="#haystackapi.providers.haystack_interface.HaystackInterface.his_write">his_write</a></code></li>
<li><code><a title="haystackapi.providers.haystack_interface.HaystackInterface.invoke_action" href="#haystackapi.providers.haystack_interface.HaystackInterface.invoke_action">invoke_action</a></code></li>
<li><code><a title="haystackapi.providers.haystack_interface.HaystackInterface.name" href="#haystackapi.providers.haystack_interface.HaystackInterface.name">name</a></code></li>
<li><code><a title="haystackapi.providers.haystack_interface.HaystackInterface.nav" href="#haystackapi.providers.haystack_interface.HaystackInterface.nav">nav</a></code></li>
<li><code><a title="haystackapi.providers.haystack_interface.HaystackInterface.ops" href="#haystackapi.providers.haystack_interface.HaystackInterface.ops">ops</a></code></li>
<li><code><a title="haystackapi.providers.haystack_interface.HaystackInterface.point_write_read" href="#haystackapi.providers.haystack_interface.HaystackInterface.point_write_read">point_write_read</a></code></li>
<li><code><a title="haystackapi.providers.haystack_interface.HaystackInterface.point_write_write" href="#haystackapi.providers.haystack_interface.HaystackInterface.point_write_write">point_write_write</a></code></li>
<li><code><a title="haystackapi.providers.haystack_interface.HaystackInterface.read" href="#haystackapi.providers.haystack_interface.HaystackInterface.read">read</a></code></li>
<li><code><a title="haystackapi.providers.haystack_interface.HaystackInterface.values_for_tag" href="#haystackapi.providers.haystack_interface.HaystackInterface.values_for_tag">values_for_tag</a></code></li>
<li><code><a title="haystackapi.providers.haystack_interface.HaystackInterface.versions" href="#haystackapi.providers.haystack_interface.HaystackInterface.versions">versions</a></code></li>
<li><code><a title="haystackapi.providers.haystack_interface.HaystackInterface.watch_poll" href="#haystackapi.providers.haystack_interface.HaystackInterface.watch_poll">watch_poll</a></code></li>
<li><code><a title="haystackapi.providers.haystack_interface.HaystackInterface.watch_sub" href="#haystackapi.providers.haystack_interface.HaystackInterface.watch_sub">watch_sub</a></code></li>
<li><code><a title="haystackapi.providers.haystack_interface.HaystackInterface.watch_unsub" href="#haystackapi.providers.haystack_interface.HaystackInterface.watch_unsub">watch_unsub</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="haystackapi.providers.haystack_interface.HttpError" href="#haystackapi.providers.haystack_interface.HttpError">HttpError</a></code></h4>
<ul class="">
<li><code><a title="haystackapi.providers.haystack_interface.HttpError.error" href="#haystackapi.providers.haystack_interface.HttpError.error">error</a></code></li>
<li><code><a title="haystackapi.providers.haystack_interface.HttpError.msg" href="#haystackapi.providers.haystack_interface.HttpError.msg">msg</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>