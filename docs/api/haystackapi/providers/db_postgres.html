<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>haystackapi.providers.db_postgres API documentation</title>
<meta name="description" content="Save Haystack ontology in Postgres database (use JSon type).
Convert the haystack filter to postgres SQL equivalent syntax." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>haystackapi.providers.db_postgres</code></h1>
</header>
<section id="section-intro">
<p>Save Haystack ontology in Postgres database (use JSon type).
Convert the haystack filter to postgres SQL equivalent syntax.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# Postgres db driver
# See the accompanying LICENSE file.
# (C) 2021 Engie Digital
#
# vim: set ts=4 sts=4 et tw=78 sw=4 si:
&#34;&#34;&#34;
Save Haystack ontology in Postgres database (use JSon type).
Convert the haystack filter to postgres SQL equivalent syntax.
&#34;&#34;&#34;
import itertools
import json
import logging
import textwrap
from abc import abstractmethod, ABC
from dataclasses import dataclass
from datetime import datetime
from typing import List, Type, Any, Union, Tuple, Optional, Dict, Iterator, Callable

from .sqldb_protocol import DBCursor
from .. import parse_filter, jsondumper, Quantity, Ref
from ..filter_ast import FilterPath, FilterBinary, FilterUnary, FilterNode

log = logging.getLogger(&#34;sql.Provider&#34;)


class _Root(ABC):  # pylint: disable=missing-module-docstring
    pass


class _IsMerge(_Root):
    @abstractmethod
    def is_merge(self) -&gt; bool:
        pass


@dataclass
class _Path(_Root):
    paths: List[str]


@dataclass
class _Has(_IsMerge):
    def is_merge(self) -&gt; bool:
        return len(self.right.paths) &gt; 1

    right: _Path


@dataclass
class _NotHas(_IsMerge):
    def is_merge(self) -&gt; bool:
        return len(self.right.paths) &gt; 1

    right: _Path


@dataclass
class _TypesHasTags(_IsMerge):
    not_op: bool
    type: Type  # HasBlock or NotHasBloc
    tags: List[str]

    def is_merge(self) -&gt; bool:
        return False


@dataclass
class _AndHasTags(_TypesHasTags):
    pass


@dataclass
class _OrHasTags(_TypesHasTags):
    pass

@dataclass
class _Intersect(_Root):
    left: _Root
    right: _Root


@dataclass
class _Union(_Root):
    left: _Root
    right: _Root


@dataclass
class _Compare(_Root):
    def is_merge(self) -&gt; bool:  # pylint: disable=no-self-use
        return False

    operator: str
    path: _Path
    value: Any


@dataclass
class _And(_Root):
    left: _Root
    right: _Root


@dataclass
class _Or(_Root):
    left: _Root
    right: _Root


def _merge_has_operators(left, right, merged_class: Type) -&gt; Optional[_Root]:
    type_left = type(left)
    type_right = type(right)
    if isinstance(left, merged_class) and left.type == type_right \
            and len(right.right.paths) == 1:
        left.tags.append(right.right.paths[0])
        return left
    if isinstance(right, merged_class) and right.type == type_left \
            and len(left.right.paths) == 1:
        right.tags.append(left.right.paths[0])
        return right
    if isinstance(left, merged_class) and isinstance(right, merged_class) \
            and left.type == right.type:
        left.tags.extend(right.tags)
        return left
    if type_left == type_right \
            and type_left in (_Has, _NotHas) \
            and len(left.right.paths) == 1 \
            and len(right.right.paths) == 1:
        return merged_class(
            type_left == _NotHas,
            type_left,
            [left.right.paths[0], right.right.paths[0]])
    return None


# Phase 1 : reorganize AST
def _optimize_filter_for_sql(node: FilterNode) -&gt; Union[_Root, FilterNode]:
    if isinstance(node, FilterPath):
        return _Path(node.paths)
    if isinstance(node, FilterBinary):
        left = _optimize_filter_for_sql(node.left)
        right = _optimize_filter_for_sql(node.right)
        if node.operator == &#34;and&#34;:
            merged = _merge_has_operators(left, right, _AndHasTags)
            if merged:
                return merged
            if isinstance(left, _IsMerge) and left.is_merge() or \
                    isinstance(right, _IsMerge) and right.is_merge() or \
                    isinstance(left, (_Union, _Intersect)) \
                    or isinstance(right, (_Union, _Intersect)):
                return _Intersect(left, right)
            return _And(left, right)
        if node.operator == &#34;or&#34;:
            merged = _merge_has_operators(left, right, _OrHasTags)
            if merged:
                return merged
            if isinstance(left, _IsMerge) and left.is_merge() or \
                    isinstance(right, _IsMerge) and right.is_merge() or \
                    isinstance(left, (_Union, _Intersect)) or \
                    isinstance(right, (_Union, _Intersect)):  # pylint: disable=too-many-boolean-expressions
                return _Union(left, right)
            return _Or(left, right)
        assert isinstance(left, _Path)
        operator = node.operator
        if operator == &#34;==&#34;:
            operator = &#34;=&#34;
        return _Compare(operator, left, right)
    if isinstance(node, FilterUnary):
        if node.operator == &#34;has&#34;:
            # right = _optimize_filter_for_sql(node.right)
            return _Has(_Path(node.right.paths))
        if node.operator == &#34;not&#34;:
            return _NotHas(_Path(node.right.paths))
        assert 0, &#34;Invalid operator&#34;
    return node  # Value


# Phase 2: Generate SQL
def _generate_sql_block(table_name: str,
                        customer_id: str,
                        version: datetime,
                        limit: int,
                        node: FilterNode,
                        num_table: int) -&gt; Tuple[int, str]:
    init_num_table = num_table
    select = [textwrap.dedent(f&#34;&#34;&#34;
        SELECT t{num_table}.entity
        FROM {table_name} as t{num_table}
        &#34;&#34;&#34;)]
    where = [_select_version(version, num_table) + \
             f&#34;AND t{num_table}.customer_id=&#39;{customer_id}&#39;\n&#34;
             f&#34;AND &#34;
             ]
    num_table, select, where = _generate_filter_in_sql(table_name, customer_id, version,
                                                       select,
                                                       where,
                                                       node,
                                                       num_table
                                                       )

    generated_sql = &#34;&#34;.join(_flatten(select))
    if init_num_table == num_table:
        generated_sql += &#34;WHERE\n&#34;
    generated_sql += &#34;&#34;.join(_flatten(where))

    if limit &gt; 0:
        generated_sql += f&#34;LIMIT {limit}\n&#34;
    return num_table, generated_sql


def _select_version(version: datetime, num_table: int) -&gt; str:
    return f&#34;&#39;{version.isoformat()}&#39; BETWEEN t{num_table}.start_datetime AND t{num_table}.end_datetime\n&#34;


def _generate_path(table_name: str,
                   customer_id: str,
                   version: datetime,
                   select: List[Union[str, List[Any]]],
                   where: List[Union[str, List[Any]]],
                   node: _Path,
                   num_table: int) -&gt; Tuple[int, List[Union[str, List[Any]]], List[Union[str, List[Any]]]]:
    if len(node.paths) == 1:
        return num_table, select, where
    first = True
    for path in node.paths[:-1]:
        num_table += 1
        if first:
            select.append(f&#34;INNER JOIN {table_name} AS t{num_table} ON\n&#34;)
        else:
            select.append(&#34;&#34;.join(_flatten(where)))
            where = []
            select.append(f&#34;INNER JOIN {table_name} AS t{num_table} ON\n&#34;)
        where.append(_select_version(version, num_table))
        where.append(f&#34;AND t{num_table}.customer_id=&#39;{customer_id}&#39;\n&#34;)
        first = False
        where.append(f&#34;AND t{num_table - 1}.entity-&gt;&#39;{path}&#39; = t{num_table}.entity-&gt;&#39;id&#39;\n&#34;)
    where.append(&#34;AND &#34;)
    return num_table, select, where


def _generate_filter_in_sql(table_name: str,
                            customer_id: str,
                            version: datetime,
                            select: List[Union[str, List[Any]]],
                            where: List[Union[str, List[Any]]],
                            node: FilterNode,
                            num_table: int
                            ) -&gt; Tuple[int, List[Union[str, List[Any]]], List[Union[str, List[Any]]]]:
    # Use RootBlock nodes
    if isinstance(node, _Has):
        num_table, select, where = \
            _generate_path(table_name, customer_id, version,
                           select, where,
                           node.right,
                           num_table)
        where.append(f&#34;t{num_table}.entity ? &#39;{node.right.paths[-1]}&#39;\n&#34;)
    elif isinstance(node, _NotHas):
        num_table, select, where = _generate_path(table_name, customer_id, version,
                                                  select, where,
                                                  node.right,
                                                  num_table)
        where.append(f&#34;NOT t{num_table}.entity ? &#39;{node.right.paths[-1]}&#39;\n&#34;)
    elif isinstance(node, _AndHasTags):
        if node.not_op:
            where.append(&#34;NOT &#34;)
        if len(node.tags) == 1:
            where.append(f&#34;t{num_table}.entity ? &#39;{node.tags[0]}&#39;\n&#34;)
        else:
            where.append(f&#34;t{num_table}.entity ?&amp; array{node.tags}\n&#34;)
    elif isinstance(node, _OrHasTags):
        where.append(f&#34;t{num_table}.entity ?| array{node.tags}\n&#34;)
    elif isinstance(node, _And):
        where.append(&#34;(&#34;)
        num_table, select, where = _generate_filter_in_sql(table_name, customer_id, version,
                                                           select,
                                                           where,
                                                           node.left,
                                                           num_table)
        where = [&#34;&#34;.join(_flatten(where))[:-1], &#34;)\nAND (&#34;]
        num_table, select, where = _generate_filter_in_sql(table_name, customer_id, version,
                                                           select,
                                                           where,
                                                           node.right,
                                                           num_table)
        where = [&#34;&#34;.join(_flatten(where))[:-1], &#34;)\n&#34;]
    elif isinstance(node, _Or):
        where.append(&#34;(&#34;)
        num_table, select, where = _generate_filter_in_sql(table_name, customer_id, version,
                                                           select,
                                                           where,
                                                           node.left,
                                                           num_table)
        where = [&#34;&#34;.join(_flatten(where))[:-1], &#34;)\nOR (&#34;]
        num_table, select, where = _generate_filter_in_sql(table_name, customer_id, version,
                                                           select,
                                                           where,
                                                           node.right,
                                                           num_table)
        where = [&#34;&#34;.join(_flatten(where))[:-1], &#34;)\n&#34;]
    elif isinstance(node, _Intersect):
        generated_sql = []
        generated_sql.append(&#39;\n(&#39;)
        num_table, sql = _generate_sql_block(table_name, customer_id, version,
                                             0,
                                             node.left,
                                             num_table)
        generated_sql.append(sql)
        generated_sql.append(&#34;)\nINTERSECT\n(&#34;)
        num_table += 1
        num_table, sql = _generate_sql_block(table_name, customer_id, version,
                                             0,
                                             node.right,
                                             num_table)
        generated_sql.append(sql)
        generated_sql.append(&#34;)\n&#34;)
        select = generated_sql
        where = []
    elif isinstance(node, _Union):
        generated_sql = []
        generated_sql.append(&#39;\n(&#39;)
        num_table, sql = _generate_sql_block(table_name, customer_id, version,
                                             0,
                                             node.left,
                                             num_table)
        generated_sql.append(sql)
        generated_sql.append(&#34;)\nUNION\n(&#34;)
        num_table += 1
        num_table, sql = _generate_sql_block(table_name, customer_id, version,
                                             0,
                                             node.right,
                                             num_table)
        generated_sql.append(sql)
        generated_sql.append(&#34;)\n&#34;)
        select = generated_sql
        where = []
    elif isinstance(node, _Compare):
        value = node.value
        if isinstance(value, Quantity):
            value = value.m
        if isinstance(value, (int, float)) and node.operator not in (&#39;=&#39;, &#39;!=&#39;):
            # Comparison with numbers. Must remove the header &#39;n:&#39;
            num_table, select, where = \
                _generate_path(table_name, customer_id, version,
                               select, where,
                               node.path,
                               num_table)
            where.extend([
                f&#34;substring(t{num_table}.entity-&gt;&gt;&#39;{node.path.paths[-1]}&#39; from 3)::float&#34;,
                f&#34; {node.operator} {value}\n&#34;,
            ])
        else:
            assert node.operator in (&#39;=&#39;, &#39;!=&#39;), &#34;Operator not supported for this type&#34;
            num_table, select, where = \
                _generate_path(table_name, customer_id, version,
                               select, where,
                               node.path,
                               num_table)
            value = json.loads(jsondumper.dump_scalar(node.value))
            if value is None:
                if node.operator == &#39;!=&#39;:
                    where.append(f&#34;t{num_table}.entity-&gt;&gt;&#39;{node.path.paths[-1]}&#39; IS NOT NULL\n&#34;)
                else:
                    where.append(f&#34;t{num_table}.entity-&gt;&gt;&#39;{node.path.paths[-1]}&#39; IS NULL\n&#34;)
            else:
                if isinstance(node.value, Ref):
                    # Comparison with Ref. Use only the name
                    where.append(f&#34;t{num_table}.entity-&gt;&gt;&#39;{node.path.paths[-1]}&#39; &#34;
                                 f&#34;LIKE &#39;{str(value)}%&#39;\n&#34;)
                else:
                    where.append(f&#34;t{num_table}.entity-&gt;&gt;&#39;{node.path.paths[-1]}&#39; &#34;
                                 f&#34;{node.operator} &#39;{str(value)}&#39;\n&#34;)
    return num_table, select, where


def _flatten(a_list: List[Any]) -&gt; Iterator[Any]:
    return itertools.chain.from_iterable(a_list)


def _sql_filter(table_name: str,
                grid_filter: Optional[str],
                version: datetime,
                limit: int = 0,
                customer_id: str = &#39;&#39;) -&gt; str:
    _, sql = _generate_sql_block(
        table_name,
        customer_id,
        version,
        limit,
        _optimize_filter_for_sql(parse_filter(grid_filter).head),  # pytlint: disable=protected-access
        num_table=1)
    sql_request = f&#39;-- {grid_filter}{sql}&#39;
    return sql_request


def _exec_sql_filter(params: Dict[str, Any],
                     cursor,
                     table_name: str,
                     grid_filter: Optional[str],
                     version: datetime,
                     limit: int = 0,
                     customer_id: str = &#39;&#39;) -&gt; DBCursor:
    if grid_filter is None or grid_filter == &#39;&#39;:
        cursor.execute(params[&#34;SELECT_ENTITY&#34;], (version, customer_id))
        return cursor

    sql_request = _sql_filter(
        table_name,
        grid_filter,
        version,
        limit,
        customer_id)
    cursor.execute(sql_request)
    return cursor


MAX_DATE = &#39;9999-12-31T23:59:59&#39;


def get_db_parameters(table_name: str) -&gt; Dict[str, Union[Callable, str]]:
    &#34;&#34;&#34; Return the SQL request and some lambda to manipulate a Postgres database.

    Args:
        table_name: The table name to use.
    Returns:
        A dictionary with SQL request or lamdas
    &#34;&#34;&#34;
    return {
        &#34;sql_type_to_json&#34;: lambda x: x,
        &#34;exec_sql_filter&#34;: _exec_sql_filter,
        &#34;field_to_datetime_tz&#34;: lambda val: val,
        &#34;datetime_tz_to_field&#34;: lambda dt: dt,
        &#34;CREATE_HAYSTACK_TABLE&#34;: textwrap.dedent(f&#39;&#39;&#39;
           CREATE TABLE IF NOT EXISTS {table_name}
               (
               id text,
               customer_id text NOT NULL,
               start_datetime timestamp WITH TIME ZONE NOT NULL,
               end_datetime timestamp WITH TIME ZONE NOT NULL,
               entity jsonb NOT NULL
               );
           &#39;&#39;&#39;),
        &#34;CREATE_HAYSTACK_INDEX_1&#34;: textwrap.dedent(f&#39;&#39;&#39;
            CREATE INDEX IF NOT EXISTS {table_name}_index ON {table_name}
            (
                id, customer_id
            )
            &#39;&#39;&#39;),
        &#34;CREATE_HAYSTACK_INDEX_2&#34;: textwrap.dedent(f&#39;&#39;&#39;
            CREATE INDEX IF NOT EXISTS {table_name}_index_gin ON {table_name} USING GIN (entity);
            &#39;&#39;&#39;),
        &#34;CREATE_METADATA_TABLE&#34;: textwrap.dedent(f&#39;&#39;&#39;
           CREATE TABLE IF NOT EXISTS {table_name}_meta_datas
               (
               customer_id text NOT NULL,
               start_datetime TIMESTAMP WITH TIME ZONE NOT NULL,
               end_datetime TIMESTAMP WITH TIME ZONE NOT NULL,
               metadata JSONB,
               cols JSONB
               );
               &#39;&#39;&#39;),
        &#34;PURGE_TABLES_HAYSTACK&#34;: textwrap.dedent(f&#39;&#39;&#39;
            DELETE FROM {table_name} ;
            &#39;&#39;&#39;),
        &#34;PURGE_TABLES_HAYSTACK_META&#34;: textwrap.dedent(f&#39;&#39;&#39;
            DELETE FROM {table_name}_meta_datas ;
            &#39;&#39;&#39;),
        &#34;SELECT_META_DATA&#34;: textwrap.dedent(f&#39;&#39;&#39;
        SELECT metadata,cols from {table_name}_meta_datas
        WHERE %s BETWEEN start_datetime AND end_datetime
        AND customer_id = %s
        &#39;&#39;&#39;),
        &#34;CLOSE_META_DATA&#34;: textwrap.dedent(f&#39;&#39;&#39;
            UPDATE {table_name}_meta_datas  SET end_datetime=%s
            WHERE %s &gt;= start_datetime AND end_datetime = &#39;9999-12-31T23:59:59&#39;
            AND customer_id=%s
            &#39;&#39;&#39;),
        &#34;UPDATE_META_DATA&#34;: textwrap.dedent(f&#39;&#39;&#39;
            INSERT INTO {table_name}_meta_datas VALUES (%s,%s,&#39;9999-12-31T23:59:59&#39;,%s,%s)
            &#39;&#39;&#39;),
        &#34;SELECT_ENTITY&#34;: textwrap.dedent(f&#39;&#39;&#39;
            SELECT entity FROM {table_name}
            WHERE %s BETWEEN start_datetime AND end_datetime
            AND customer_id = %s
            &#39;&#39;&#39;),
        &#34;SELECT_ENTITY_WITH_ID&#34;: textwrap.dedent(f&#39;&#39;&#39;
            SELECT entity FROM {table_name}
            WHERE %s BETWEEN start_datetime AND end_datetime
            AND customer_id = %s
            AND id IN &#39;&#39;&#39;),
        &#34;CLOSE_ENTITY&#34;: textwrap.dedent(f&#39;&#39;&#39;
            UPDATE {table_name} SET end_datetime=%s 
            WHERE 
            %s BETWEEN start_datetime AND end_datetime
            AND id=%s 
            AND customer_id=%s
            &#39;&#39;&#39;),
        &#34;INSERT_ENTITY&#34;: textwrap.dedent(f&#39;&#39;&#39;
            INSERT INTO {table_name} VALUES (%s,%s,%s,&#39;9999-12-31T23:59:59&#39;,%s)
            &#39;&#39;&#39;),
        &#34;DISTINCT_VERSION&#34;: textwrap.dedent(f&#39;&#39;&#39;
            SELECT DISTINCT start_datetime
            FROM {table_name}
            WHERE customer_id=%s
            ORDER BY start_datetime
            &#39;&#39;&#39;),
        &#34;DISTINCT_TAG_VALUES&#34;: textwrap.dedent(f&#39;&#39;&#39;
            SELECT DISTINCT entity-&gt;&#39;[#]&#39;
            FROM {table_name}
            WHERE customer_id = %s
            &#39;&#39;&#39;),

        &#34;CREATE_TS_TABLE&#34;: textwrap.dedent(f&#39;&#39;&#39;
            CREATE TABLE IF NOT EXISTS {table_name}_ts
                (
                id TEXT NOT NULL, 
                customer_id TEXT NOT NULL, 
                date_time TIMESTAMP WITH TIME ZONE NOT NULL, 
                val JSONB NOT NULL
                );
        &#39;&#39;&#39;),
        &#34;CREATE_TS_INDEX&#34;: textwrap.dedent(f&#39;&#39;&#39;
            CREATE INDEX IF NOT EXISTS {table_name}_ts_index ON {table_name}_ts(id,customer_id)
            &#39;&#39;&#39;),
        &#34;CLEAN_TS&#34;: textwrap.dedent(f&#39;&#39;&#39;
            DELETE FROM {table_name}_ts
            WHERE customer_id = %s
            AND id = %s
            AND date_time BETWEEN %s AND %s
            &#39;&#39;&#39;),
        &#34;INSERT_TS&#34;: textwrap.dedent(f&#39;&#39;&#39;
            INSERT INTO {table_name}_ts
            VALUES(%s,%s,%s,%s)
            &#39;&#39;&#39;),
        &#34;SELECT_TS&#34;: textwrap.dedent(f&#39;&#39;&#39;
            SELECT date_time,val FROM {table_name}_ts
            WHERE customer_id = %s
            AND id = %s
            AND date_time BETWEEN %s AND %s
            ORDER BY date_time
            &#39;&#39;&#39;),
        &#34;PURGE_TABLES_TS&#34;: textwrap.dedent(f&#39;&#39;&#39;
            DELETE FROM {table_name}_ts
            &#39;&#39;&#39;)
    }</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="haystackapi.providers.db_postgres.get_db_parameters"><code class="name flex">
<span>def <span class="ident">get_db_parameters</span></span>(<span>table_name: str) ‑> Dict[str, Union[Callable, str]]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the SQL request and some lambda to manipulate a Postgres database.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>table_name</code></strong></dt>
<dd>The table name to use.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary with SQL request or lamdas</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_db_parameters(table_name: str) -&gt; Dict[str, Union[Callable, str]]:
    &#34;&#34;&#34; Return the SQL request and some lambda to manipulate a Postgres database.

    Args:
        table_name: The table name to use.
    Returns:
        A dictionary with SQL request or lamdas
    &#34;&#34;&#34;
    return {
        &#34;sql_type_to_json&#34;: lambda x: x,
        &#34;exec_sql_filter&#34;: _exec_sql_filter,
        &#34;field_to_datetime_tz&#34;: lambda val: val,
        &#34;datetime_tz_to_field&#34;: lambda dt: dt,
        &#34;CREATE_HAYSTACK_TABLE&#34;: textwrap.dedent(f&#39;&#39;&#39;
           CREATE TABLE IF NOT EXISTS {table_name}
               (
               id text,
               customer_id text NOT NULL,
               start_datetime timestamp WITH TIME ZONE NOT NULL,
               end_datetime timestamp WITH TIME ZONE NOT NULL,
               entity jsonb NOT NULL
               );
           &#39;&#39;&#39;),
        &#34;CREATE_HAYSTACK_INDEX_1&#34;: textwrap.dedent(f&#39;&#39;&#39;
            CREATE INDEX IF NOT EXISTS {table_name}_index ON {table_name}
            (
                id, customer_id
            )
            &#39;&#39;&#39;),
        &#34;CREATE_HAYSTACK_INDEX_2&#34;: textwrap.dedent(f&#39;&#39;&#39;
            CREATE INDEX IF NOT EXISTS {table_name}_index_gin ON {table_name} USING GIN (entity);
            &#39;&#39;&#39;),
        &#34;CREATE_METADATA_TABLE&#34;: textwrap.dedent(f&#39;&#39;&#39;
           CREATE TABLE IF NOT EXISTS {table_name}_meta_datas
               (
               customer_id text NOT NULL,
               start_datetime TIMESTAMP WITH TIME ZONE NOT NULL,
               end_datetime TIMESTAMP WITH TIME ZONE NOT NULL,
               metadata JSONB,
               cols JSONB
               );
               &#39;&#39;&#39;),
        &#34;PURGE_TABLES_HAYSTACK&#34;: textwrap.dedent(f&#39;&#39;&#39;
            DELETE FROM {table_name} ;
            &#39;&#39;&#39;),
        &#34;PURGE_TABLES_HAYSTACK_META&#34;: textwrap.dedent(f&#39;&#39;&#39;
            DELETE FROM {table_name}_meta_datas ;
            &#39;&#39;&#39;),
        &#34;SELECT_META_DATA&#34;: textwrap.dedent(f&#39;&#39;&#39;
        SELECT metadata,cols from {table_name}_meta_datas
        WHERE %s BETWEEN start_datetime AND end_datetime
        AND customer_id = %s
        &#39;&#39;&#39;),
        &#34;CLOSE_META_DATA&#34;: textwrap.dedent(f&#39;&#39;&#39;
            UPDATE {table_name}_meta_datas  SET end_datetime=%s
            WHERE %s &gt;= start_datetime AND end_datetime = &#39;9999-12-31T23:59:59&#39;
            AND customer_id=%s
            &#39;&#39;&#39;),
        &#34;UPDATE_META_DATA&#34;: textwrap.dedent(f&#39;&#39;&#39;
            INSERT INTO {table_name}_meta_datas VALUES (%s,%s,&#39;9999-12-31T23:59:59&#39;,%s,%s)
            &#39;&#39;&#39;),
        &#34;SELECT_ENTITY&#34;: textwrap.dedent(f&#39;&#39;&#39;
            SELECT entity FROM {table_name}
            WHERE %s BETWEEN start_datetime AND end_datetime
            AND customer_id = %s
            &#39;&#39;&#39;),
        &#34;SELECT_ENTITY_WITH_ID&#34;: textwrap.dedent(f&#39;&#39;&#39;
            SELECT entity FROM {table_name}
            WHERE %s BETWEEN start_datetime AND end_datetime
            AND customer_id = %s
            AND id IN &#39;&#39;&#39;),
        &#34;CLOSE_ENTITY&#34;: textwrap.dedent(f&#39;&#39;&#39;
            UPDATE {table_name} SET end_datetime=%s 
            WHERE 
            %s BETWEEN start_datetime AND end_datetime
            AND id=%s 
            AND customer_id=%s
            &#39;&#39;&#39;),
        &#34;INSERT_ENTITY&#34;: textwrap.dedent(f&#39;&#39;&#39;
            INSERT INTO {table_name} VALUES (%s,%s,%s,&#39;9999-12-31T23:59:59&#39;,%s)
            &#39;&#39;&#39;),
        &#34;DISTINCT_VERSION&#34;: textwrap.dedent(f&#39;&#39;&#39;
            SELECT DISTINCT start_datetime
            FROM {table_name}
            WHERE customer_id=%s
            ORDER BY start_datetime
            &#39;&#39;&#39;),
        &#34;DISTINCT_TAG_VALUES&#34;: textwrap.dedent(f&#39;&#39;&#39;
            SELECT DISTINCT entity-&gt;&#39;[#]&#39;
            FROM {table_name}
            WHERE customer_id = %s
            &#39;&#39;&#39;),

        &#34;CREATE_TS_TABLE&#34;: textwrap.dedent(f&#39;&#39;&#39;
            CREATE TABLE IF NOT EXISTS {table_name}_ts
                (
                id TEXT NOT NULL, 
                customer_id TEXT NOT NULL, 
                date_time TIMESTAMP WITH TIME ZONE NOT NULL, 
                val JSONB NOT NULL
                );
        &#39;&#39;&#39;),
        &#34;CREATE_TS_INDEX&#34;: textwrap.dedent(f&#39;&#39;&#39;
            CREATE INDEX IF NOT EXISTS {table_name}_ts_index ON {table_name}_ts(id,customer_id)
            &#39;&#39;&#39;),
        &#34;CLEAN_TS&#34;: textwrap.dedent(f&#39;&#39;&#39;
            DELETE FROM {table_name}_ts
            WHERE customer_id = %s
            AND id = %s
            AND date_time BETWEEN %s AND %s
            &#39;&#39;&#39;),
        &#34;INSERT_TS&#34;: textwrap.dedent(f&#39;&#39;&#39;
            INSERT INTO {table_name}_ts
            VALUES(%s,%s,%s,%s)
            &#39;&#39;&#39;),
        &#34;SELECT_TS&#34;: textwrap.dedent(f&#39;&#39;&#39;
            SELECT date_time,val FROM {table_name}_ts
            WHERE customer_id = %s
            AND id = %s
            AND date_time BETWEEN %s AND %s
            ORDER BY date_time
            &#39;&#39;&#39;),
        &#34;PURGE_TABLES_TS&#34;: textwrap.dedent(f&#39;&#39;&#39;
            DELETE FROM {table_name}_ts
            &#39;&#39;&#39;)
    }</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="haystackapi.providers" href="index.html">haystackapi.providers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="haystackapi.providers.db_postgres.get_db_parameters" href="#haystackapi.providers.db_postgres.get_db_parameters">get_db_parameters</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>